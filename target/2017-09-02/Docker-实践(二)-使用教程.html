<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
    
      Docker 实践(二)：使用教程 &middot; Tairy's Blog
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/styles.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">
</head>


  <body>
    <nav class="nav">
      <div class="nav-container">
        <a href="/">
          <h2 class="nav-title">Tairy's Blog</h2>
        </a>
        <ul>
          <li><a href="/about/">About</a></li>
          <li><a href="/">Posts</a></li>
        </ul>
    </div>
  </nav>

    <main>
      <div class="post">
  <div class="post-info">
    <span>Written by&nbsp;</span>Tairy

    
      <br>
      <span>on&nbsp;</span><time datetime="2017-09-02 00:00:00 +0800">September 02, 2017</time>
    
  </div>

  <h1 class="post-title">Docker 实践(二)：使用教程</h1>
  <div class="post-line"></div>

  <blockquote>
  <p>docker 即容器</p>
</blockquote>

<h3 id="一些概念">一些概念</h3>

<h4 id="docker-registry">Docker Registry</h4>

<p>Docker 远程镜像仓库</p>

<ul>
  <li>DockerHub</li>
  <li>DaoCloud / Aliyun</li>
</ul>

<h4 id="docker-images">Docker Images</h4>

<p><code class="highlighter-rouge">Docker Images</code> 是用来创建 docker 容器的只读模版，其中包含了容器启动所需要的所有配置信息和运行程序，一次构建之后可以多次复用。</p>

<p>从结构上来讲，<code class="highlighter-rouge">Docker Image</code> 是分层次的，如图所示：</p>

<p><img src="http://ww1.sinaimg.cn/mw1024/9631b1bbgw1f6hl1rxvt7j20g8072mxa.jpg" alt="" /></p>

<p>这样就自然出现了父镜像和基础镜像的概念，在图中，每一个上层镜像都是依赖于下一层的镜像，所以下层镜像可称为上层镜像的父镜像，而最底层的镜像是没有父镜像的，可称其为基础镜像（Base Image）。</p>

<p>实际场景下，一般我们自己创建的镜像都会依赖于某个 <code class="highlighter-rouge">Linux</code> 操作系统的镜像，例如 <code class="highlighter-rouge">ubuntu</code>，大多数情况下，我们可称其为基础镜像，但是我们也可以查看 <code class="highlighter-rouge">ubuntu</code> 镜像的 <code class="highlighter-rouge">Dockerfile</code> 会发现，它也是依赖于一个叫 <code class="highlighter-rouge">scratch</code> 的镜像，<code class="highlighter-rouge">scratch</code> 是 <code class="highlighter-rouge">docker</code> 的一个空镜像，里面只有 <code class="highlighter-rouge">docker</code> 加入的一些元数据，如果我们想要追求自己的镜像尽可能的轻量，也可以将 <code class="highlighter-rouge">scratch</code> 镜像作为我们的基础镜像来构建。</p>

<h4 id="dockerfile">Dockerfile</h4>

<p><code class="highlighter-rouge">Dockerfile</code> 是用来说明如何自动构建 <code class="highlighter-rouge">docker image</code> 的指令集文件，在 <code class="highlighter-rouge">Dockerfile</code> 中编写好指令集之后，我们就可以通过 <code class="highlighter-rouge">docker build</code> 命令构建镜像，<code class="highlighter-rouge">Dockerfile</code> 文件中命令的顺序就是构建过程中执行的顺序。</p>

<p>以下为几个常用的指令：</p>

<h5 id="1-from依赖镜像">1. FROM：依赖镜像</h5>

<p>所有 <code class="highlighter-rouge">Dockerfile</code> 都必须以 <code class="highlighter-rouge">FROM</code> 命令开始，表示其依赖的镜像。</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>FROM image_name
</code></pre>
</div>

<h5 id="2-maintainer镜像作者信息">2. MAINTAINER：镜像作者信息</h5>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>MAINTAINER author &lt;author_email&gt;
</code></pre>
</div>

<h5 id="3-run在shell或者exec的环境下执行的命令">3. RUN：在shell或者exec的环境下执行的命令</h5>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>RUN &lt;<span class="nb">command</span>&gt;
</code></pre>
</div>

<h5 id="4-add将主机文件复制到容器中">4. ADD：将主机文件复制到容器中</h5>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>ADD /path/to/sourcefile/in/host /path/to/targetfile/in/container
</code></pre>
</div>

<h5 id="5-cmd指定容器启动默认执行的命令">5. CMD：指定容器启动默认执行的命令</h5>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>CMD <span class="o">[</span><span class="s2">"executable"</span>,<span class="s2">"param1"</span>,<span class="s2">"param2"</span><span class="o">]</span>
</code></pre>
</div>

<h5 id="6-expose指定容器在运行时监听的端口">6. EXPOSE：指定容器在运行时监听的端口</h5>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>EXPOSE &lt;port&gt;
</code></pre>
</div>

<h5 id="7-workdir指定runcmd与-entrypoint-命令的工作目录">7. WORKDIR：指定<code class="highlighter-rouge">RUN</code>、<code class="highlighter-rouge">CMD</code>与 <code class="highlighter-rouge">ENTRYPOINT</code> 命令的工作目录</h5>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>WORKDIR /path/to/workdir/in/container
</code></pre>
</div>

<h5 id="8-volume授权访问从容器内到主机上的目录">8. VOLUME：授权访问从容器内到主机上的目录</h5>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>VOLUME <span class="o">[</span><span class="s2">"/data"</span><span class="o">]</span>
</code></pre>
</div>

<p>关于 <code class="highlighter-rouge">Dockerfile</code> 编写有以下几点需要注意：</p>

<ul>
  <li>尽量不要省略 <code class="highlighter-rouge">MAINTAINER</code> 信息。</li>
  <li><code class="highlighter-rouge">EXPOSE</code> 的端口不使用公有端口。</li>
  <li><code class="highlighter-rouge">CMD</code> 与 <code class="highlighter-rouge">ENTRYPOINT</code> 命令使用数组语法。</li>
</ul>

<p>另外，在国内使用 <code class="highlighter-rouge">docker</code>（以 ubuntu 为例）， <code class="highlighter-rouge">Dockerfile</code> 第一个执行的命令最好为（具体原因你猜）：</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>RUN sed -i <span class="s1">'s/archive.ubuntu.com/mirrors.aliyun.com/g'</span> /etc/apt/sources.list <span class="se">\</span>
    <span class="o">&amp;&amp;</span> apt-get update --fix-missing <span class="se">\</span>
    <span class="o">&amp;&amp;</span> apt-get -y upgrade
</code></pre>
</div>

<h4 id="docker-container">Docker Container</h4>

<p><code class="highlighter-rouge">Docker Container</code> 中包含了我们的应用代码和代码执行的环境，是用来打包分发代码的单元。</p>

<h3 id="构建镜像">构建镜像</h3>

<p>首先要编写 <code class="highlighter-rouge">Dockerfile</code>，在文件中写入构建镜像需要的指令集，然后执行下面命令：</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>docker build <span class="o">{</span>image_name<span class="o">}</span> <span class="o">{</span>/path/to/Dockerfile<span class="o">}</span>
</code></pre>
</div>

<p>例如，我们构建一个 <code class="highlighter-rouge">mysql</code> 的镜像，先编写 <code class="highlighter-rouge">Dockerfile</code></p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>FROM ubuntu:14.04
MAINTAINER Tairy &lt;tairyguo@gmail.com&gt;

<span class="c"># Install Base.</span>
RUN <span class="se">\</span>
  sed -i <span class="s1">'s/archive.ubuntu.com/mirrors.aliyun.com/g'</span> /etc/apt/sources.list <span class="o">&amp;&amp;</span> <span class="se">\</span>
  apt-get update <span class="o">&amp;&amp;</span> <span class="se">\</span>
  apt-get -y upgrade <span class="o">&amp;&amp;</span> <span class="se">\</span>
  apt-get install -y build-essential <span class="o">&amp;&amp;</span> <span class="se">\</span>
  apt-get install -y software-properties-common <span class="o">&amp;&amp;</span> <span class="se">\</span>
  apt-get install -y byobu curl git htop man unzip vim wget

RUN apt-get -y install mysql-server

EXPOSE 3306

CMD <span class="o">[</span><span class="s2">"mysqld"</span><span class="o">]</span>
</code></pre>
</div>

<p>执行</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>docker build -t mysql ./
</code></pre>
</div>
<p>构建工具将先在本地查找 <code class="highlighter-rouge">ubuntu:14.04</code> 的镜像，如果有，则直接依赖使用，如果没有，将去远程的仓库中下载官方构建的 <code class="highlighter-rouge">ubuntu:14.04</code> 的镜像，当然因为一些不可描述的原因，这个下载过程成功率不大，而且非常耗时，所以我们可以做如下优化：</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>docker pull daocloud.io/library/ubuntu:wily-20160706
</code></pre>
</div>

<p>然后将 <code class="highlighter-rouge">Dockerfile</code> 中 <code class="highlighter-rouge">FROM</code> 命令修改为：</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="c"># 我注册了daocloud 账号，就使用 daocloud 的镜像，也可以选择使用阿里云的镜像。</span>
FROM daocloud.io/library/ubuntu:wily-20160706
</code></pre>
</div>

<p>这样，就节省了很多的时间。</p>

<blockquote>
  <p>总之，在安装环境的过程中，因为某个伟大的防火墙工程，我们需要的大部分资源都没法顺利的获取到，解决办法就是将下载的源换成国内某些厂商提供的镜像源。（推荐阿里云，毕竟有钱，稳定。）</p>
</blockquote>

<p>经过一段时间的自动构建，便可生成一个可用的 <code class="highlighter-rouge">mysql</code> 镜像，使用 <code class="highlighter-rouge">docker images</code> 命令查看构建好的镜像列表，输出：</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>REPOSITORY        TAG                 IMAGE ID            CREATED             SIZE
mysql            latest              ffe5a4341fee        1 days ago          1.009 GB
</code></pre>
</div>

<p>删除一个镜像，使用下面命令：</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="c"># -f 表示强制删除，慎重使用</span>
docker rmi -f image_name
</code></pre>
</div>

<h3 id="创建容器">创建容器</h3>

<p>有了基础的镜像模板之后，就可以创建容器来执行应用代码，具体用到 <code class="highlighter-rouge">run</code> 命令：</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>docker run <span class="o">[</span>OPTIONS] IMAGE <span class="o">[</span>COMMAND] <span class="o">[</span>ARG...]
</code></pre>
</div>
<p>例如我们要创建一个运行 mysql 的容器，可以执行</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>docker run -d --name db1 -v <span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>:/data:rw -p 8001:3306 mysql
</code></pre>
</div>

<p>这条命令将创建后台执行的 mysql 容器，里面运行一个 mysql 服务器，可以使用 <code class="highlighter-rouge">docker ps</code> 命令查看启动的容器。</p>

<ul>
  <li>-d 参数表示后台守护进程运行容器。</li>
  <li>–name 参数表示容器的名称，可随意取。</li>
  <li>-v 表示主机和容器共享文件的映射，容器的目录就是 Dockerfile 中用 VOLUME 命令定义的目录。</li>
  <li>-p 表器主机和容器端口映射，容器的端口就是 Dockerfile 中用 EXPOSE 命令绑定的端口。</li>
</ul>

<blockquote>
  <p><strong>关于创建容器的时候的坑：</strong></p>

  <p>一般来说，我们会在 <code class="highlighter-rouge">Dockerfile</code> 中的最后用 CMD 命令定义容器启动之后执行的命令，但是如果我们定义的命令执行报错或者命令没有创建一个守护进程的话，<code class="highlighter-rouge">docker ps</code> 之后是看不到容器在运行的，此时可以使用 <code class="highlighter-rouge">docker l	ogs</code> 命令查看容器启动的日志，进行排错。</p>
</blockquote>

<p>当然，我们也可以在 run 的时候定义容器启动的命令，例如下面命令将启动一个 ubuntu 的容器，并执行 <code class="highlighter-rouge">/bin/bash</code> 程序，进入 ubuntu 的 terminal：</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>docker run -it ubuntu:14.04 /bin/bash
</code></pre>
</div>

<p>此命令成功的标志就是你会发现命令行变成了类似：</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">root@d71ff8587917:/# </span>
</code></pre>
</div>
<p>说明现在已经进入了 <code class="highlighter-rouge">ubuntu</code> 的容器中，可以直接在此命令行中操作 <code class="highlighter-rouge">ubuntu</code>，或者输入 <code class="highlighter-rouge">exit</code> 回车之后即可退出，退出之后再 <code class="highlighter-rouge">docker ps</code> 会发现容器也不再运行了。</p>

<p><strong>一些常用命令:</strong></p>

<ul>
  <li><code class="highlighter-rouge">docker ps -a</code> 命令可以列出所有的容器，包括已经终止运行的。</li>
  <li><code class="highlighter-rouge">docker rm container_name/container_id</code> 可以删除某个容器。</li>
  <li><code class="highlighter-rouge">docker start container_name/container_id</code> 启动某个容器。</li>
  <li><code class="highlighter-rouge">docker stop container_name/container_id</code> 终止某个容器。</li>
  <li><code class="highlighter-rouge">docker exec -it contaner_name /bin/bash</code> 在容器中执行 <code class="highlighter-rouge">/bin/bash</code>，执行该命令之后将可以以交互命令行的方式操作容器，另外 <code class="highlighter-rouge">/bin/bash</code> 可以替换成任意可执行命令。</li>
</ul>

<h3 id="docker-compose">Docker compose</h3>

<p><code class="highlighter-rouge">docker-compose</code> 是用来创建和管理多容器应用的工具，使用 <code class="highlighter-rouge">docker-compose</code> 只需三步：</p>

<ol>
  <li>编写应用运行环境的 <code class="highlighter-rouge">Dockerfile</code>，即 image。</li>
  <li>编写 <code class="highlighter-rouge">docker-compose.yml</code>，在 <code class="highlighter-rouge">services</code> 块下指定容器相关参数以及与其它容器的依赖关系。</li>
  <li>执行 <code class="highlighter-rouge">docker-compose up</code>，运行应用。</li>
</ol>

<p>一个简单的 <code class="highlighter-rouge">docker-compose.yml</code> 如下：</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>version: <span class="s1">'2'</span> <span class="c"># compose 版本，当前为 2</span>
services:
  web: <span class="c"># web 容器</span>
    build: . <span class="c"># Dockerfile 所在路径</span>
    ports:
    - <span class="s2">"5000:5000"</span> <span class="c"># 端口映射</span>
    volumes:
    - .:/code <span class="c"># 文件路径映射</span>
    - logvolume01:/var/log
    links:
    - redis <span class="c"># 链接容器</span>
  redis:
    image: redis <span class="c"># 定义链接容器</span>
volumes:
  logvolume01: <span class="o">{}</span>
</code></pre>
</div>

<ul>
  <li><a href="https://docs.docker.com/compose/compose-file/">Compose file reference</a></li>
</ul>


</div>

<div class="pagination">
  
    <a href="http://0.0.0.0:4000/2017-09-03/Docker-%E5%AE%9E%E8%B7%B5(%E4%B8%89)-Mac-%E4%B8%8B%E6%9E%84%E5%BB%BA-Rails-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83" class="left arrow">&#8592;</a>
  
  
    <a href="http://0.0.0.0:4000/2017-09-01/Docker-%E5%AE%9E%E8%B7%B5(%E4%B8%80)-%E4%BA%86%E8%A7%A3%E6%9E%B6%E6%9E%84" class="right arrow">&#8594;</a>
  

  <a href="#" class="top">Top</a>
</div>
    </main>

    <footer>
      <span>
        &copy; <time datetime="2017-09-13 00:05:16 +0800">2017</time> . Made with Jekyll using the <a href="https://github.com/chesterhow/tale/">Tale</a> theme.
      </span>
    </footer>
  </body>
</html>
